package A_OnsiteClassical.Tiktok;

import java.util.Arrays;

class MinimizeMalwareSpread924 {
  public int minMalwareSpread(int[][] graph, int[] initial) {
    int n = graph.length;
    UnionFind uf = new UnionFind(n);
    for (int i = 0; i < n; ++i) {
      for (int j = i + 1; j < n; ++j) {
        if (graph[i][j] == 1) {
          uf.union(i, j);
        }
      }
    }
    System.out.println("uf size array = " + Arrays.toString(uf.size));

    int res = n;
    int min = n, max = 0;
    int[] cnt = new int[n];
    for (int i : initial) {
      cnt[uf.find(i)]++;
      min = Math.min(min, i);
    }
    System.out.println("cnt array = " + Arrays.toString(cnt));

    for (int x : initial) {
      int root = uf.find(x);
      System.out.println("x = " + x + " root = " + root);
      // find a group with only one infected nodes
      if (cnt[root] == 1) {
        int size = uf.size(root);
        if (size > max || (size == max && x < res)) {
          res = x;
          max = size;
        }
      }
    }

    return res == n ? min : res;
  }
}

class UnionFind {
  private final int[] parent;
  final int[] size;

  public UnionFind(int n) {
    parent = new int[n];
    size = new int[n];

    for (int i = 0; i < n; ++i) {
      parent[i] = i;
      size[i] = 1;
    }
  }

  public int find(int x) {
    if (parent[x] != x) {
      parent[x] = find(parent[x]);
    }

    return parent[x];
  }

  public boolean union(int a, int b) {
    int pa = find(a), pb = find(b);

    if (pa == pb) {
      return false;
    }

    if (size[pa] > size[pb]) {
      parent[pb] = pa;
      size[pa] += size[pb];
    } else {
      parent[pa] = pb;
      size[pb] += size[pa];
    }

    return true;
  }

  public int size(int root) {
    return size[root];
  }
}
